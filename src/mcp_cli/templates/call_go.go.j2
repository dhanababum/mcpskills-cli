// Call MCP tool on server '{{ server_name }}'.
// Usage: go run call.go <tool_name> [json_args]
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const server = "{{ server_name }}"

func loadCredentials() (string, string) {
	home, _ := os.UserHomeDir()
	data, err := os.ReadFile(filepath.Join(home, ".mcps", "credentials"))
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	var url, token string
	inSection := false
	scanner := bufio.NewScanner(bytes.NewReader(data))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == fmt.Sprintf("[%s]", server) {
			inSection = true
			continue
		}
		if inSection && strings.HasPrefix(line, "[") {
			break
		}
		if inSection {
			if k, v, ok := strings.Cut(line, "="); ok {
				switch strings.TrimSpace(k) {
				case "url":
					url = strings.TrimSpace(v)
				case "token":
					token = strings.TrimSpace(v)
				}
			}
		}
	}
	if url == "" || token == "" {
		fmt.Fprintf(os.Stderr, "Missing url or token for [%s]\n", server)
		os.Exit(1)
	}
	if !strings.HasSuffix(url, "/") {
		url += "/"
	}
	return url, token
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <tool_name> [json_args]\n", os.Args[0])
		os.Exit(1)
	}
	toolName := os.Args[1]
	args := json.RawMessage("{}")
	if len(os.Args) > 2 {
		args = json.RawMessage(os.Args[2])
	}
	url, token := loadCredentials()
	body, _ := json.Marshal(map[string]any{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params":  map[string]any{"name": toolName, "arguments": args},
		"id":      1,
	})
	req, _ := http.NewRequest("POST", url, bytes.NewReader(body))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json, text/event-stream")
	req.Header.Set("MCP-Protocol-Version", "2025-06-18")
	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	defer resp.Body.Close()
	raw, _ := io.ReadAll(resp.Body)
	for _, line := range strings.Split(string(raw), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "data:") {
			line = strings.TrimSpace(line[5:])
		}
		if line == "" || line == "[DONE]" {
			continue
		}
		var obj map[string]any
		if json.Unmarshal([]byte(line), &obj) == nil {
			if _, ok := obj["result"]; ok {
				out, _ := json.MarshalIndent(obj, "", "  ")
				fmt.Println(string(out))
				return
			}
			if _, ok := obj["error"]; ok {
				out, _ := json.MarshalIndent(obj, "", "  ")
				fmt.Println(string(out))
				return
			}
		}
	}
	fmt.Println(string(raw))
}
